import * as vscode from 'vscode';
import { ElementInfo, DOMSnapshot, CaptureOptions } from '../types';
import { Logger } from '../utils/logger';
import { PlaywrightCapture } from '../capture/PlaywrightCapture';
import { DomSerializer } from '../capture/DomSerializer';
// import { ElementInspector } from '../inspector/ElementInspector'; // Not used in current implementation
// AI functionality now integrated with Cursor Chat

export class WebviewProvider {
    private panel: vscode.WebviewPanel | undefined;
    private readonly context: vscode.ExtensionContext;
    private readonly logger: Logger;
    private readonly playwrightCapture: PlaywrightCapture;
    private readonly domSerializer: DomSerializer;
    // private readonly elementInspector: ElementInspector; // Unused but kept for future enhancements
    private selectedElement: ElementInfo | undefined;

    constructor(context: vscode.ExtensionContext) {
        this.context = context;
        this.logger = new Logger();
        this.playwrightCapture = new PlaywrightCapture();
        this.domSerializer = new DomSerializer();
        // this.elementInspector = new ElementInspector(); // Unused but kept for future enhancements
    }

    public async captureAndShowWebpage(url: string): Promise<void> {
        this.logger.info('Starting webpage capture', { url });
        
        try {
            // Create webview panel first
            this.createWebviewPanel();
            
            // Show loading state
            this.updateWebviewContent(this.getLoadingContent());
            
            // Get capture options from configuration (with fallback for no workspace)
            let config;
            try {
                config = vscode.workspace.getConfiguration('domAgent');
            } catch (error) {
                // Fallback when no workspace is open
                config = { get: () => undefined };
            }
            
            const captureOptions: CaptureOptions = {
                browser: config?.get?.('defaultBrowser') || 'chromium',
                viewport: { width: 1280, height: 720 },
                timeout: 30000
            };
            
            // Capture the webpage
            this.logger.info('Capturing DOM with Playwright', { options: captureOptions });
            const snapshot = await this.playwrightCapture.captureWebpage(url, captureOptions);
            
            // Process and display the captured content
            this.displayCapturedWebpage(snapshot);
            
            this.logger.info('Webpage capture completed successfully', { 
                url: snapshot.url,
                elements: snapshot.elements.length 
            });
            
        } catch (error) {
            this.logger.error('Failed to capture webpage', error);
            
            if (this.panel) {
                this.updateWebviewContent(this.getErrorContent(error));
            }
            
            vscode.window.showErrorMessage(
                `Failed to capture webpage: ${error instanceof Error ? error.message : 'Unknown error'}`
            );
        }
    }

    public getSelectedElement(): ElementInfo | undefined {
        return this.selectedElement;
    }

    public dispose(): void {
        if (this.panel) {
            this.panel.dispose();
            this.panel = undefined;
        }
        
        // Cleanup Playwright resources
        this.playwrightCapture.cleanup().catch(error => {
            this.logger.error('Error during Playwright cleanup', error);
        });
    }

    private displayCapturedWebpage(snapshot: DOMSnapshot): void {
        if (!this.panel) {
            this.logger.error('Cannot display captured webpage: panel not initialized');
            return;
        }

        this.logger.info('Displaying captured webpage in webview');
        
        // Sanitize and process HTML
        const sanitizedHtml = this.domSerializer.sanitizeHTML(snapshot.html);
        const interactivityScript = this.domSerializer.injectInteractivityScript();
        
        this.logger.info('Injected interactivity script length:', interactivityScript.length);
        this.logger.info('Script preview:', interactivityScript.substring(0, 200) + '...');
        
        // Create the interactive webview content
        const webviewContent = this.createInteractiveWebviewContent(
            snapshot,
            sanitizedHtml,
            interactivityScript
        );
        
        this.updateWebviewContent(webviewContent);
    }

    private createInteractiveWebviewContent(
        snapshot: DOMSnapshot, 
        sanitizedHtml: string, 
        interactivityScript: string
    ): string {
        // Extract head and body content
        const headMatch = sanitizedHtml.match(/<head[^>]*>([\s\S]*?)<\/head>/i);
        const bodyMatch = sanitizedHtml.match(/<body[^>]*>([\s\S]*?)<\/body>/i);
        
        const headContent = headMatch ? headMatch[1] : '';
        const bodyContent = bodyMatch ? bodyMatch[1] : sanitizedHtml;
        
        return `
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>DOM Agent - ${snapshot.url}</title>
            <style>
                /* Base styles */
                * {
                    box-sizing: border-box;
                }
                
                body {
                    margin: 0;
                    padding: 0;
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                }
                
                /* Toolbar styles */
                .dom-agent-toolbar {
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    height: 40px;
                    background: var(--vscode-editor-background, #1e1e1e);
                    border-bottom: 1px solid var(--vscode-panel-border, #333);
                    display: flex !important;
                    align-items: center;
                    padding: 0 12px;
                    z-index: 10001;
                    gap: 12px;
                    font-size: 12px;
                    color: var(--vscode-foreground, #cccccc);
                    pointer-events: auto;
                    visibility: visible !important;
                    opacity: 1 !important;
                }
                
                .dom-agent-toolbar .url {
                    font-weight: 500;
                    opacity: 0.8;
                    color: var(--vscode-foreground, #cccccc);
                }
                
                .dom-agent-toolbar .info {
                    margin-left: auto;
                    opacity: 0.6;
                    color: var(--vscode-foreground, #cccccc);
                }
                
                /* 现代极简 Inspector Panel */
                .dom-agent-inspector {
                    position: fixed;
                    width: 260px;
                    max-height: 400px;
                    background: #ffffff;
                    border: 1px solid #e1e5e9;
                    border-radius: 8px;
                    box-shadow: 
                        0 4px 20px rgba(0, 0, 0, 0.08),
                        0 1px 3px rgba(0, 0, 0, 0.1);
                    z-index: 10002;
                    overflow: hidden;
                    font-size: 12px;
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    color: #1a1a1a;
                    opacity: 0;
                    visibility: hidden;
                    transform: translateY(6px);
                    transition: all 0.2s cubic-bezier(0.16, 1, 0.3, 1);
                    pointer-events: auto;
                }
                
                .dom-agent-inspector.active {
                    opacity: 1;
                    visibility: visible;
                    transform: translateY(0);
                }
                
                /* Inspector positioning classes */
                .dom-agent-inspector.position-right {
                    right: 20px;
                    top: 60px;
                }
                
                .dom-agent-inspector.position-left {
                    left: 20px;
                    top: 60px;
                }
                
                .dom-agent-inspector.position-top {
                    top: 60px;
                    left: 50%;
                    transform: translateX(-50%) scale(0.9) translateY(10px);
                }
                
                .dom-agent-inspector.position-top.active {
                    transform: translateX(-50%) scale(1) translateY(0);
                }
                
                .dom-agent-inspector.position-bottom {
                    bottom: 20px;
                    left: 50%;
                    transform: translateX(-50%) scale(0.9) translateY(-10px);
                }
                
                .dom-agent-inspector.position-bottom.active {
                    transform: translateX(-50%) scale(1) translateY(0);
                }
                
                /* 极简头部 */
                .dom-agent-inspector-header {
                    background: #ffffff;
                    padding: 12px 16px;
                    border-bottom: 1px solid #f0f0f0;
                    display: flex;
                    align-items: center;
                    justify-content: space-between;
                    min-height: 40px;
                }
                
                .dom-agent-inspector-title {
                    font-size: 14px;
                    font-weight: 600;
                    color: #1a1a1a;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    letter-spacing: -0.01em;
                }
                
                .dom-agent-inspector-badge {
                    background: linear-gradient(135deg, 
                        rgba(96, 165, 250, 0.8) 0%, 
                        rgba(139, 92, 246, 0.8) 100%);
                    color: rgba(255, 255, 255, 0.95);
                    padding: 4px 8px;
                    border-radius: 8px;
                    font-size: 9px;
                    font-weight: 600;
                    text-transform: uppercase;
                    letter-spacing: 0.5px;
                    backdrop-filter: blur(4px);
                }
                
                .dom-agent-inspector-controls {
                    display: flex;
                    gap: 6px;
                }
                
                .dom-agent-inspector-btn {
                    width: 24px;
                    height: 24px;
                    border: none;
                    background: transparent;
                    border-radius: 4px;
                    color: #6b7280;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 11px;
                    transition: all 0.15s ease;
                }
                
                .dom-agent-inspector-btn:hover {
                    background: #f3f4f6;
                    color: #374151;
                }
                
                .dom-agent-inspector-btn:active {
                    background: #e5e7eb;
                }
                
                /* 极简内容区 */
                .dom-agent-inspector-content {
                    padding: 0;
                    max-height: 350px;
                    overflow-y: auto;
                    background: #ffffff;
                }
                
                .dom-agent-inspector-content::-webkit-scrollbar {
                    width: 6px;
                }
                
                .dom-agent-inspector-content::-webkit-scrollbar-track {
                    background: transparent;
                }
                
                .dom-agent-inspector-content::-webkit-scrollbar-thumb {
                    background: #d1d5db;
                    border-radius: 3px;
                }
                
                .dom-agent-inspector-content::-webkit-scrollbar-thumb:hover {
                    background: #9ca3af;
                }
                
                /* 极简区块样式 */
                .dom-agent-inspector .section {
                    margin: 0;
                    border: none;
                    background: #ffffff;
                }
                
                .dom-agent-inspector .section:last-child {
                    border-bottom: none;
                }
                
                .dom-agent-inspector .section h3 {
                    margin: 0;
                    padding: 16px 16px 8px;
                    font-size: 12px;
                    font-weight: 600;
                    color: #1a1a1a;
                    background: #ffffff;
                    border: none;
                    display: flex;
                    align-items: center;
                    gap: 4px;
                    letter-spacing: -0.01em;
                }
                
                .dom-agent-inspector .section-content {
                    padding: 0 16px 16px;
                }
                
                .dom-agent-inspector .property {
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    margin-bottom: 8px;
                    padding: 0;
                    font-size: 12px;
                    line-height: 1.4;
                }
                
                .dom-agent-inspector .property:last-child {
                    margin-bottom: 0;
                }
                
                .dom-agent-inspector .property-name {
                    font-size: 12px;
                    font-weight: 400;
                    color: #1a1a1a;
                    white-space: nowrap;
                    flex-shrink: 0;
                    margin-right: 12px;
                }
                
                .dom-agent-inspector .property-value {
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    font-size: 12px;
                    font-weight: 400;
                    color: #6b7280;
                    word-break: break-word;
                    text-align: right;
                    flex: 1;
                }
                
                /* Enhanced form controls */
                .dom-agent-inspector select,
                .dom-agent-inspector input[type="checkbox"] {
                    background: rgba(0, 0, 0, 0.4);
                    border: 1px solid rgba(63, 63, 70, 0.6);
                    border-radius: 6px;
                    color: #f4f4f5;
                    transition: all 0.2s ease;
                }
                
                .dom-agent-inspector select {
                    background: #ffffff;
                    border: 1px solid #d1d5db;
                    border-radius: 6px;
                    color: #374151;
                    padding: 6px 10px;
                    font-size: 12px;
                    cursor: pointer;
                    outline: none;
                    appearance: none;
                    background-image: url('data:image/svg+xml;charset=US-ASCII,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 4 5"><path fill="%23374151" d="m0 1 2 2 2-2z"/></svg>');
                    background-repeat: no-repeat;
                    background-position: right 8px center;
                    background-size: 10px;
                    padding-right: 28px;
                    transition: all 0.15s ease;
                }
                
                .dom-agent-inspector select:focus {
                    border-color: #3b82f6;
                    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
                }
                
                .dom-agent-inspector input[type="checkbox"] {
                    width: 14px;
                    height: 14px;
                    margin: 0;
                    cursor: pointer;
                }
                
                .dom-agent-inspector label {
                    display: flex;
                    align-items: center;
                    gap: 6px;
                    font-size: 11px;
                    color: #d4d4d8;
                    cursor: pointer;
                    padding: 2px 0;
                }
                
                .dom-agent-inspector button {
                    background: #f9fafb;
                    border: 1px solid #d1d5db;
                    border-radius: 6px;
                    color: #374151;
                    padding: 8px 12px;
                    font-size: 12px;
                    font-weight: 500;
                    cursor: pointer;
                    width: 100%;
                    transition: all 0.15s ease;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    gap: 6px;
                    font-family: inherit;
                }
                
                .dom-agent-inspector button:hover {
                    background: #f3f4f6;
                    border-color: #9ca3af;
                }
                
                .dom-agent-inspector button:active {
                    background: #e5e7eb;
                }
                
                .dom-agent-inspector button:disabled {
                    opacity: 0.4;
                    cursor: not-allowed;
                }
                
                /* Modern Scrollbar Styles */
                ::-webkit-scrollbar {
                    width: 8px;
                    height: 8px;
                }
                
                ::-webkit-scrollbar-track {
                    background: #f1f1f1;
                    border-radius: 4px;
                    margin: 2px;
                }
                
                ::-webkit-scrollbar-thumb {
                    background: #c1c1c1;
                    border-radius: 4px;
                    border: 1px solid #f1f1f1;
                }
                
                ::-webkit-scrollbar-thumb:hover {
                    background: #a8a8a8;
                }
                
                ::-webkit-scrollbar-thumb:active {
                    background: #888888;
                }
                
                /* Inspector Panel Custom Scrollbar */
                .custom-scrollbar::-webkit-scrollbar {
                    width: 6px;
                    height: 6px;
                }
                
                .custom-scrollbar::-webkit-scrollbar-track {
                    background: transparent;
                    border-radius: 3px;
                }
                
                .custom-scrollbar::-webkit-scrollbar-thumb {
                    background: rgba(156, 163, 175, 0.3);
                    border-radius: 3px;
                    transition: all 0.2s ease;
                }
                
                .custom-scrollbar::-webkit-scrollbar-thumb:hover {
                    background: rgba(107, 114, 128, 0.6);
                }
                
                .custom-scrollbar::-webkit-scrollbar-thumb:active {
                    background: rgba(75, 85, 99, 0.8);
                }
                
                /* Inspector Panel Overall */
                .dom-agent-inspector ::-webkit-scrollbar {
                    width: 6px;
                }
                
                .dom-agent-inspector ::-webkit-scrollbar-track {
                    background: transparent;
                    border-radius: 3px;
                }
                
                .dom-agent-inspector ::-webkit-scrollbar-thumb {
                    background: rgba(156, 163, 175, 0.3);
                    border-radius: 3px;
                    transition: all 0.2s ease;
                }
                
                .dom-agent-inspector ::-webkit-scrollbar-thumb:hover {
                    background: rgba(107, 114, 128, 0.6);
                }
                
                .dom-agent-inspector ::-webkit-scrollbar-thumb:active {
                    background: rgba(75, 85, 99, 0.8);
                }
                
                /* Firefox Scrollbar */
                * {
                    scrollbar-width: thin;
                    scrollbar-color: rgba(156, 163, 175, 0.4) transparent;
                }
                
                .custom-scrollbar {
                    scrollbar-width: thin;
                    scrollbar-color: rgba(156, 163, 175, 0.3) transparent;
                }
                
                .dom-agent-inspector {
                    scrollbar-width: thin;
                    scrollbar-color: rgba(156, 163, 175, 0.3) transparent;
                }
                
                /* Smooth Scrolling for all elements */
                * {
                    scroll-behavior: smooth;
                }
                
                .custom-scrollbar {
                    scroll-behavior: smooth;
                }

                /* Content area - no longer needs margin adjustments */
                .dom-agent-content {
                    margin-top: 40px;
                    position: relative;
                }
                
                /* Captured styles */
                ${snapshot.css}
            </style>
            ${headContent}
            <!-- Tailwind CSS CDN -->
            <script src="https://cdn.tailwindcss.com"></script>
        </head>
        <body>
            <!-- DOM Agent Toolbar -->
            <div class="dom-agent-toolbar">
                <div class="url">📄 ${snapshot.url}</div>
                <div class="info">${snapshot.elements.length} elements captured • ${new Date(snapshot.timestamp).toLocaleTimeString()}</div>
            </div>
            
            <!-- Tailwind CSS Shadcn UI Inspector Panel -->
            <div class="fixed right-5 top-1/2 -translate-y-1/2 w-80 max-h-[28rem] bg-white border border-gray-200 rounded-xl shadow-lg shadow-gray-900/10 z-[10002] overflow-hidden text-sm font-sans text-gray-900 opacity-0 invisible translate-y-2 transition-all duration-200 ease-out pointer-events-auto" id="inspector">
                <!-- Header -->
                <div class="flex items-center justify-between px-6 py-4 border-b border-gray-100">
                    <h3 class="text-base font-semibold text-gray-900 flex items-center gap-2">
                        <span class="text-lg">🔍</span>
                        Element Inspector
                    </h3>
                    <div class="flex items-center gap-1">
                        <button class="inline-flex items-center justify-center w-7 h-7 rounded-md hover:bg-gray-100 text-gray-500 hover:text-gray-700 transition-colors duration-150" id="inspector-pin" title="Pin position">
                            📌
                        </button>
                        <button class="inline-flex items-center justify-center w-7 h-7 rounded-md hover:bg-gray-100 text-gray-500 hover:text-gray-700 transition-colors duration-150" id="inspector-close" title="Close">
                            ✕
                        </button>
                    </div>
                </div>
                <!-- Content -->
                <div class="max-h-80 overflow-y-auto custom-scrollbar" id="inspector-content">
                    <div class="section">
                        <div class="section-content">
                            <p style="opacity: 0.6; text-align: center; margin: 40px 20px; font-size: 13px; line-height: 1.5;">
                                ✨ Click on any element in the webpage to inspect it and generate code with AI
                            </p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Captured Content -->
            <div class="dom-agent-content" id="content">
                ${bodyContent}
            </div>
            
            <script>
                // Debug function for Cursor compatibility
                function debugLog(message, data) {
                    console.log('[DOM Agent Debug]', message, data);
                }
                
                // Variables for hover behavior
                let inspectorHideTimeout = null;
                let isInspectorHovered = false;
                let isInspectorVisible = false;
                let currentInspectorElement = null;
                
                // Handle mouse movement for inspector following
                let mouseMoveTimeout = null;
                window.addEventListener('mousemove', (event) => {
                    if (isInspectorVisible && currentInspectorElement) {
                        // Debounce mouse movement to avoid excessive updates
                        clearTimeout(mouseMoveTimeout);
                        mouseMoveTimeout = setTimeout(() => {
                            const inspector = document.getElementById('inspector');
                            if (inspector) {
                                positionInspectorDynamically(inspector, {
                                    x: event.clientX,
                                    y: event.clientY
                                });
                            }
                        }, 16); // ~60fps update rate
                    }
                });
                
                // Handle element selection and hover messages
                window.addEventListener('message', (event) => {
                    debugLog('Message received:', event.data);
                    
                    if (event.data.type === 'element-selected') {
                        const { element, position } = event.data.payload;
                        debugLog('Element selected:', element);
                        
                        showElementInspector(element, position);
                        
                        // Send to VS Code extension
                        if (window.parent && window.parent !== window) {
                            debugLog('Sending message to parent');
                            window.parent.postMessage({
                                type: 'element-selected',
                                payload: { element, position }
                            }, '*');
                        }
                    } else if (event.data.type === 'element-hovered') {
                        const { element, position } = event.data.payload;
                        debugLog('Element hovered:', element);
                        
                        // Clear any pending hide timeout
                        if (inspectorHideTimeout) {
                            clearTimeout(inspectorHideTimeout);
                            inspectorHideTimeout = null;
                        }
                        
                        showElementInspectorOnHover(element, position);
                    } else if (event.data.type === 'element-unhovered') {
                        debugLog('Element unhovered');
                        
                        // Hide inspector after delay if not hovering over it
                        if (!isInspectorHovered) {
                            inspectorHideTimeout = setTimeout(() => {
                                hideElementInspector();
                            }, 150); // Small delay to allow moving to inspector
                        }
                    }
                });
                
                // Dynamic inspector positioning for hover behavior
                function positionInspectorDynamically(inspector, mousePos) {
                    const viewportWidth = window.innerWidth;
                    const viewportHeight = window.innerHeight;
                    const inspectorWidth = 320;
                    const inspectorHeight = 400;
                    const offsetX = 15; // Offset from cursor
                    const offsetY = 15;
                    const padding = 10; // Margin from viewport edges
                    
                    // Remove all position classes - we'll use absolute positioning
                    inspector.classList.remove('position-right', 'position-left', 'position-top', 'position-bottom');
                    
                    // Calculate initial position (bottom-right of cursor)
                    let posX = mousePos.x + offsetX;
                    let posY = mousePos.y + offsetY;
                    
                    // Adjust if would overflow viewport bounds
                    if (posX + inspectorWidth > viewportWidth - padding) {
                        posX = mousePos.x - inspectorWidth - offsetX; // Position to left of cursor
                    }
                    
                    if (posY + inspectorHeight > viewportHeight - padding) {
                        posY = mousePos.y - inspectorHeight - offsetY; // Position above cursor
                    }
                    
                    // Ensure minimum padding from edges
                    posX = Math.max(padding, Math.min(posX, viewportWidth - inspectorWidth - padding));
                    posY = Math.max(padding, Math.min(posY, viewportHeight - inspectorHeight - padding));
                    
                    // Apply dynamic positioning with CSS
                    inspector.style.position = 'fixed';
                    inspector.style.left = posX + 'px';
                    inspector.style.top = posY + 'px';
                    inspector.style.right = 'auto';
                    inspector.style.bottom = 'auto';
                    inspector.style.transform = 'none'; // Remove transform-based positioning
                    
                    // Add smooth transition for following movement
                    if (isInspectorVisible) {
                        inspector.style.transition = 'left 0.1s cubic-bezier(0.4, 0, 0.2, 1), top 0.1s cubic-bezier(0.4, 0, 0.2, 1)';
                    } else {
                        inspector.style.transition = 'opacity 0.2s cubic-bezier(0.16, 1, 0.3, 1), visibility 0.2s, transform 0.2s cubic-bezier(0.16, 1, 0.3, 1)';
                    }
                }
                
                // Show inspector on hover (DevTools-like behavior)
                function showElementInspectorOnHover(element, position) {
                    debugLog('showElementInspectorOnHover called', { element, position });
                    
                    const inspector = document.getElementById('inspector');
                    const inspectorContent = document.getElementById('inspector-content');
                    
                    if (!inspector || !inspectorContent) {
                        debugLog('ERROR: Inspector elements not found!');
                        return;
                    }
                    
                    // Store current element and enable tracking
                    currentSelectedElement = element;
                    currentInspectorElement = element;
                    isInspectorVisible = true;
                    
                    // Dynamic positioning that follows mouse cursor
                    positionInspectorDynamically(inspector, position || { x: window.innerWidth / 2, y: window.innerHeight / 2 });
                    
                    // Show inspector panel with smooth animation
                    debugLog('Showing inspector on hover with Tailwind classes');
                    inspector.classList.remove('opacity-0', 'invisible', 'translate-y-2');
                    inspector.classList.add('opacity-100', 'visible', 'translate-y-0');
                    
                    // Add hover-specific styling (lighter background)
                    inspector.style.background = 'rgba(255, 255, 255, 0.95)';
                    inspector.style.backdropFilter = 'blur(12px)';
                    
                    // Populate content (same as click version but indicate it's hover mode)
                    populateInspectorContent(inspectorContent, element, 'hover');
                }
                
                // Hide inspector when element unhovered
                function hideElementInspector() {
                    debugLog('hideElementInspector called');
                    
                    const inspector = document.getElementById('inspector');
                    if (!inspector) return;
                    
                    // Clear tracking state
                    isInspectorVisible = false;
                    currentInspectorElement = null;
                    
                    inspector.classList.add('opacity-0', 'invisible', 'translate-y-2');
                    inspector.classList.remove('opacity-100', 'visible', 'translate-y-0');
                }

                function showElementInspector(element, clickPosition) {
                    debugLog('showElementInspector called', { element, clickPosition });
                    
                    // Store the current selected element globally
                    currentSelectedElement = element;
                    
                    const inspector = document.getElementById('inspector');
                    const inspectorContent = document.getElementById('inspector-content');
                    
                    debugLog('Inspector elements found:', { inspector: !!inspector, inspectorContent: !!inspectorContent });
                    
                    if (!inspector || !inspectorContent) {
                        debugLog('ERROR: Inspector elements not found!');
                        return;
                    }
                    
                    // Smart positioning based on available space
                    positionInspectorSmartly(inspector, clickPosition || { x: window.innerWidth / 2, y: window.innerHeight / 2 });
                    
                    // Show inspector panel with Tailwind classes
                    debugLog('Showing inspector with Tailwind classes');
                    inspector.classList.remove('opacity-0', 'invisible', 'translate-y-2');
                    inspector.classList.add('opacity-100', 'visible', 'translate-y-0');
                    
                    // Reset to click-specific styling (solid background)
                    inspector.style.background = 'white';
                    inspector.style.backdropFilter = 'none';
                    
                    // Populate content
                    populateInspectorContent(inspectorContent, element, 'click');
                }
                
                // Populate inspector content with element info
                function populateInspectorContent(inspectorContent, element, mode = 'click') {
                    const modeIndicator = mode === 'hover' ? '👁️ Hovering' : '🎯 Selected';
                    const actionsVisible = mode === 'click'; // Only show actions when clicked
                    
                    inspectorContent.innerHTML = \`
                        <!-- Element Properties Section -->
                        <div class="border-b border-gray-100 last:border-b-0">
                            <div class="px-6 py-4">
                                <div class="flex items-center justify-between mb-3">
                                    <h4 class="text-sm font-medium text-gray-900">
                                        \${element.tag}\${element.id ? '#' + element.id : ''}\${element.classes.length ? '.' + element.classes[0] : ''}
                                    </h4>
                                    <span class="text-xs text-gray-500 bg-gray-100 px-2 py-1 rounded-full">\${modeIndicator}</span>
                                </div>
                                <dl class="space-y-2">
                                    <div class="flex justify-between items-center">
                                        <dt class="text-sm text-gray-600">Tag</dt>
                                        <dd class="text-sm font-mono text-gray-900">&lt;\${element.tag}&gt;</dd>
                                    </div>
                                    \${element.id ? \`<div class="flex justify-between items-center">
                                        <dt class="text-sm text-gray-600">ID</dt>
                                        <dd class="text-sm font-mono text-gray-900">#\${element.id}</dd>
                                    </div>\` : ''}
                                    \${element.classes.length > 0 ? \`<div class="flex justify-between items-center">
                                        <dt class="text-sm text-gray-600">Classes</dt>
                                        <dd class="text-sm font-mono text-gray-900">.\${element.classes.join(' .')}</dd>
                                    </div>\` : ''}
                                    <div class="flex justify-between items-center">
                                        <dt class="text-sm text-gray-600">Size</dt>
                                        <dd class="text-sm font-mono text-gray-900">\${element.boundingBox.width} × \${element.boundingBox.height}px</dd>
                                    </div>
                                    \${element.textContent && element.textContent.trim().length > 0 ? \`<div class="flex justify-between items-start">
                                        <dt class="text-sm text-gray-600">Text</dt>
                                        <dd class="text-sm text-gray-900 text-right max-w-40 truncate">"\${element.textContent.trim().length > 20 ? element.textContent.trim().substring(0, 20) + '...' : element.textContent.trim()}"</dd>
                                    </div>\` : ''}
                                </dl>
                            </div>
                        </div>
                        
                        \${actionsVisible ? \`
                        <!-- Actions Section -->
                        <div class="p-6 space-y-4">
                            <h4 class="text-sm font-medium text-gray-900">Actions</h4>
                            
                            
                            <!-- Configuration Selects -->
                            <div class="grid grid-cols-2 gap-2">
                                <select id="framework-select" class="block w-full rounded-md border-gray-300 py-2 pl-3 pr-10 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500">
                                    <option value="react">React</option>
                                    <option value="vue">Vue</option>
                                    <option value="angular">Angular</option>
                                    <option value="vanilla">JavaScript</option>
                                </select>
                                <select id="type-select" class="block w-full rounded-md border-gray-300 py-2 pl-3 pr-10 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500">
                                    <option value="component">Component</option>
                                    <option value="test">Test</option>
                                    <option value="accessibility">Accessibility</option>
                                </select>
                            </div>
                            
                            <!-- Cursor Chat Button -->
                            <button onclick="openCursorChat()" id="cursor-chat-btn" 
                                    class="w-full inline-flex items-center justify-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-colors">
                                <span class="mr-2">💬</span>
                                Open Cursor Chat
                            </button>
                        </div>
                        \` : ''}
                    \`;
                }
                
                // Initialize inspector controls
                document.addEventListener('DOMContentLoaded', function() {
                    const inspectorClose = document.getElementById('inspector-close');
                    const inspectorPin = document.getElementById('inspector-pin');
                    const inspector = document.getElementById('inspector');
                    
                    // Add mouse event listeners to inspector panel for hover behavior
                    if (inspector) {
                        inspector.addEventListener('mouseenter', function() {
                            debugLog('Inspector panel mouse enter');
                            isInspectorHovered = true;
                            
                            // Clear any pending hide timeout
                            if (inspectorHideTimeout) {
                                clearTimeout(inspectorHideTimeout);
                                inspectorHideTimeout = null;
                            }
                        });
                        
                        inspector.addEventListener('mouseleave', function() {
                            debugLog('Inspector panel mouse leave');
                            isInspectorHovered = false;
                            
                            // Hide inspector after delay
                            inspectorHideTimeout = setTimeout(() => {
                                hideElementInspector();
                            }, 300); // Small delay before hiding
                        });
                    }
                    
                    if (inspectorClose) {
                        inspectorClose.addEventListener('click', function() {
                            inspector.classList.add('opacity-0', 'invisible', 'translate-y-2');
                            inspector.classList.remove('opacity-100', 'visible', 'translate-y-0');
                        });
                    }
                    
                    if (inspectorPin) {
                        let isPinned = false;
                        inspectorPin.addEventListener('click', function() {
                            isPinned = !isPinned;
                            if (isPinned) {
                                inspectorPin.textContent = '📍';
                                inspectorPin.title = 'Unpin position';
                                inspector.style.position = 'fixed';
                            } else {
                                inspectorPin.textContent = '📌';
                                inspectorPin.title = 'Pin position';
                            }
                        });
                    }
                });
                
                function copyToClipboard(text, type, buttonElement) {
                    navigator.clipboard.writeText(text).then(() => {
                        // Show temporary feedback
                        const button = buttonElement || window.event?.target;
                        if (button) {
                            const originalText = button.textContent;
                            button.textContent = 'Copied!';
                            setTimeout(() => {
                                button.textContent = originalText;
                            }, 1500);
                        }
                    }).catch(err => {
                        console.error('Failed to copy to clipboard:', err);
                        alert('Copied: ' + text);
                    });
                }
                
                // Store current selected element globally for access
                let currentSelectedElement = null;
                
                function openCursorChat() {
                    console.log('[DOM Agent] openCursorChat called');
                    
                    const framework = document.getElementById('framework-select').value;
                    const type = document.getElementById('type-select').value;
                    
                    console.log('[DOM Agent] Framework:', framework, 'Type:', type);
                    
                    // Get current selected element info from the latest selection
                    const inspector = document.getElementById('inspector');
                    if (!inspector.classList.contains('active') || !currentSelectedElement) {
                        console.log('[DOM Agent] No element selected');
                        alert('Please select an element first');
                        return;
                    }
                    
                    // Send message to parent window (VS Code webview)
                    if (window.parent && window.parent.postMessage) {
                        console.log('[DOM Agent] Sending message to parent with element:', currentSelectedElement);
                        window.parent.postMessage({
                            type: 'open-cursor-chat',
                            payload: {
                                element: currentSelectedElement,
                                framework,
                                type
                            }
                        }, '*');
                    } else {
                        console.log('[DOM Agent] Cannot send message to parent');
                        alert('Cannot communicate with extension');
                    }
                }
                
                // Listen for messages from extension
                window.addEventListener('message', event => {
                    const message = event.data;
                    switch (message.type) {
                        case 'cursor-chat-opened':
                            const statusDiv = document.getElementById('chat-status');
                            if (statusDiv) {
                                statusDiv.innerHTML = \`
                                    <div style="color: var(--vscode-charts-green);">
                                        ✅ Cursor Chat opened with element context
                                    </div>
                                \`;
                            }
                            break;
                        case 'cursor-chat-error':
                            const status = document.getElementById('chat-status');
                            if (status) {
                                status.innerHTML = \`
                                    <div style="color: var(--vscode-errorForeground);">
                                        ❌ Could not open Cursor Chat
                                    </div>
                                \`;
                            }
                            break;
                    }
                });
                
                // Expose all inspector functions globally for Cursor compatibility
                // This must be after all function definitions
                window.showElementInspector = showElementInspector;
                window.showElementInspectorOnHover = showElementInspectorOnHover;  
                window.hideElementInspector = hideElementInspector;
                window.populateInspectorContent = populateInspectorContent;
                window.debugLog = debugLog;
                
                console.log('[DOM Agent Debug] All inspector functions exposed to window for Cursor compatibility');
                console.log('[DOM Agent] Functions exposed to window:', {
                    showElementInspector: typeof window.showElementInspector,
                    showElementInspectorOnHover: typeof window.showElementInspectorOnHover,
                    hideElementInspector: typeof window.hideElementInspector,  
                    populateInspectorContent: typeof window.populateInspectorContent,
                    debugLog: typeof window.debugLog
                });
                
            </script>
            
            <!-- DOM Agent Interactivity Script Start -->
            <script src="https://cdn.jsdelivr.net/npm/driver.js@1.3.1/dist/driver.js.iife.js"></script>
            <script src="https://unpkg.com/tippy.js@6/dist/tippy-bundle.umd.js"></script>
            <link rel="stylesheet" href="https://unpkg.com/tippy.js@6/themes/light-border.css">
            <script>
                console.log('[DOM Agent] DOM Agent selection script DISABLED to remove all buttons');
                // Script completely disabled to prevent button creation
                if (false) {
                console.log('[DOM Agent] DOM Agent selection script starting...');
                
                // Wait for libraries to load
                let driver = null;
                let driverInitialized = false;
                let tippyAvailable = false;
                
                // Check library availability
                function checkLibraries() {
                    console.log('[DOM Agent] Checking library availability...');
                    console.log('[DOM Agent] Driver.js available:', typeof Driver !== 'undefined');
                    console.log('[DOM Agent] Tippy.js available:', typeof tippy !== 'undefined');
                    
                    if (typeof tippy !== 'undefined') {
                        tippyAvailable = true;
                        console.log('[DOM Agent] Tippy.js loaded successfully');
                    } else {
                        console.warn('[DOM Agent] Tippy.js not loaded, will use fallback');
                    }
                }
                
                function initializeDriver() {
                    if (typeof Driver !== 'undefined' && !driverInitialized) {
                        console.log('[DOM Agent] Initializing Driver.js...');
                        driver = new Driver({
                            showProgress: false,
                            showButtons: false,
                            allowClose: false,
                            overlayClickNext: false,
                            keyboardControl: true,
                            smoothScroll: false,
                            animate: false,  // Disable animations to prevent flickering
                            padding: 4,
                            popoverClass: 'dom-agent-popover',
                            popoverOffset: 10
                        });
                        driverInitialized = true;
                        console.log('[DOM Agent] Driver.js initialized successfully');
                        return true;
                    }
                    return false;
                }
                
                // Initialize libraries
                checkLibraries();
                
                // Try to initialize driver
                if (!initializeDriver()) {
                    // If not loaded yet, wait a bit
                    setTimeout(() => {
                        checkLibraries();
                        if (!initializeDriver()) {
                            console.warn('[DOM Agent] Driver.js failed to load, using fallback');
                        }
                    }, 500);
                }
                
                let currentHoveredElement = null;
                
                // Helper functions for Driver.js popover content
                function getElementTitle(element) {
                    const tagName = element.tagName.toLowerCase();
                    const id = element.id ? '#' + element.id : '';
                    const className = element.className ? '.' + Array.from(element.classList).join('.') : '';
                    return tagName + id + className || 'Element';
                }
                
                function getElementDescription(element) {
                    const rect = element.getBoundingClientRect();
                    const text = element.textContent ? element.textContent.trim().substring(0, 50) + '...' : '';
                    return Math.round(rect.width) + 'x' + Math.round(rect.height) + 'px' + (text ? ' • ' + text : '');
                }
                
                // Generate comprehensive element info for copying
                function getElementInfo(element) {
                    const tagName = element.tagName.toLowerCase();
                    const id = element.id;
                    const classes = Array.from(element.classList);
                    const rect = element.getBoundingClientRect();
                    const text = element.textContent ? element.textContent.trim() : '';
                    
                    const info = {
                        tag: tagName,
                        id: id || '',
                        classes: classes.join(' '),
                        selector: getElementSelector(element),
                        xpath: getElementXPath(element),
                        dimensions: {
                            width: Math.round(rect.width),
                            height: Math.round(rect.height),
                            x: Math.round(rect.left),
                            y: Math.round(rect.top)
                        },
                        text: text.substring(0, 200),
                        attributes: getElementAttributes(element)
                    };
                    
                    return info;
                }
                
                // Generate CSS selector for element
                function getElementSelector(element) {
                    const tagName = element.tagName.toLowerCase();
                    const id = element.id ? '#' + element.id : '';
                    const classes = element.className ? '.' + Array.from(element.classList).join('.') : '';
                    return tagName + id + classes;
                }
                
                // Generate XPath for element
                function getElementXPath(element) {
                    if (element.id !== '') {
                        return '//*[@id="' + element.id + '"]';
                    }
                    if (element === document.body) {
                        return '/html/body';
                    }
                    
                    let ix = 0;
                    const siblings = element.parentNode ? element.parentNode.childNodes : [];
                    for (let i = 0; i < siblings.length; i++) {
                        const sibling = siblings[i];
                        if (sibling === element) {
                            return getElementXPath(element.parentNode) + '/' + element.tagName.toLowerCase() + '[' + (ix + 1) + ']';
                        }
                        if (sibling.nodeType === 1 && sibling.tagName === element.tagName) {
                            ix++;
                        }
                    }
                }
                
                // Get element attributes
                function getElementAttributes(element) {
                    const attrs = {};
                    for (let i = 0; i < element.attributes.length; i++) {
                        const attr = element.attributes[i];
                        attrs[attr.name] = attr.value;
                    }
                    return attrs;
                }
                
                // Copy element info to clipboard (exposed globally)
                window.copyElementInfo = function(element, format = 'json') {
                    console.log('[DOM Agent] Copy button clicked:', format, element);
                    
                    if (!element) {
                        console.error('[DOM Agent] No element provided to copy function');
                        showNotification('❌ No element found');
                        return;
                    }
                    const info = getElementInfo(element);
                    let textToCopy = '';
                    
                    switch (format) {
                        case 'json':
                            textToCopy = JSON.stringify(info, null, 2);
                            break;
                        case 'css':
                            textToCopy = info.selector;
                            break;
                        case 'xpath':
                            textToCopy = info.xpath;
                            break;
                        case 'summary':
                            textToCopy = \`Element: \${info.tag}
ID: \${info.id || 'none'}
Classes: \${info.classes || 'none'}
Selector: \${info.selector}
XPath: \${info.xpath}
Size: \${info.dimensions.width}x\${info.dimensions.height}px
Position: (\${info.dimensions.x}, \${info.dimensions.y})
Text: \${info.text || 'none'}\`;
                            break;
                        default:
                            textToCopy = JSON.stringify(info, null, 2);
                    }
                    
                    // Try modern clipboard API first
                    if (navigator.clipboard && navigator.clipboard.writeText) {
                        navigator.clipboard.writeText(textToCopy).then(() => {
                            console.log('[DOM Agent] Element info copied to clipboard:', format);
                            showNotification(\`📋 \${format.toUpperCase()} copied to clipboard\`);
                        }).catch(err => {
                            console.error('[DOM Agent] Modern clipboard failed:', err);
                            // Fallback to legacy method
                            copyTextFallback(textToCopy, format);
                        });
                    } else {
                        // Use fallback method
                        copyTextFallback(textToCopy, format);
                    }
                }
                
                // Fallback copy method using temporary textarea
                function copyTextFallback(text, format) {
                    try {
                        const textarea = document.createElement('textarea');
                        textarea.value = text;
                        textarea.style.position = 'fixed';
                        textarea.style.left = '-999999px';
                        textarea.style.top = '-999999px';
                        document.body.appendChild(textarea);
                        textarea.focus();
                        textarea.select();
                        const successful = document.execCommand('copy');
                        document.body.removeChild(textarea);
                        
                        if (successful) {
                            console.log('[DOM Agent] Fallback copy successful:', format);
                            showNotification(\`📋 \${format.toUpperCase()} copied to clipboard\`);
                        } else {
                            console.error('[DOM Agent] Fallback copy failed');
                            showNotification('❌ Failed to copy to clipboard');
                        }
                    } catch (err) {
                        console.error('[DOM Agent] Fallback copy error:', err);
                        showNotification('❌ Copy not supported in this browser');
                    }
                }
                
                // Create overlay with inspector bar
                function createOverlay() {
                    if (overlayDiv) return;
                    
                    overlayDiv = document.createElement('div');
                    // Dynamic selection box styling will be applied per element
                    overlayDiv.style.cssText = 'position: absolute; display: none; pointer-events: none; z-index: 10000; transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1); box-sizing: border-box;';
                    
                    // No inspector bar to avoid CSS/XPath buttons - just the selection overlay
                    
                    document.body.appendChild(overlayDiv);
                    console.log('[DOM Agent] Overlay with inspector bar created');
                }
                
                // Update overlay position and inspector content
                async function updateOverlay(element) {
                    if (!overlayDiv || !element) return;
                    
                    const rect = element.getBoundingClientRect();
                    const scrollX = window.pageXOffset || document.documentElement.scrollLeft;
                    const scrollY = window.pageYOffset || document.documentElement.scrollTop;
                    const viewportWidth = window.innerWidth;
                    const viewportHeight = window.innerHeight;
                    
                    overlayDiv.style.left = (rect.left + scrollX) + 'px';
                    overlayDiv.style.top = (rect.top + scrollY) + 'px';
                    overlayDiv.style.width = rect.width + 'px';
                    overlayDiv.style.height = rect.height + 'px';
                    overlayDiv.style.display = 'block';
                    
                    // Apply smart selection box styling based on element size
                    applySmartSelectionStyle(overlayDiv, rect);
                    
                    // No inspector bar to update - just the selection overlay
                }
                
                // Update inspector content with responsive design
                function updateInspectorContent(element, infoSection, buttonSection, rect) {
                    const tagName = element.tagName.toLowerCase();
                    const id = element.id;
                    const classes = Array.from(element.classList);
                    const viewportWidth = window.innerWidth || document.documentElement.clientWidth;
                    
                    // Advanced responsive content based on available space and element context
                    const isNarrow = viewportWidth < 600;
                    const isVeryNarrow = viewportWidth < 400;
                    
                    // Detect compact mode for buttons and small elements
                    const isCompactElement = rect.width < 80 && rect.height < 40;
                    const hasLimitedSpace = (rect.left < 50) || (viewportWidth - rect.left - rect.width < 50) || 
                                          (rect.top < 50) || (window.innerHeight - rect.top - rect.height < 50);
                    const needsCompactMode = isVeryNarrow || isCompactElement || hasLimitedSpace;
                    
                    // Build element identifier with intelligent truncation
                    let elementId;
                    
                    if (needsCompactMode) {
                        // Ultra-compact mode - minimal essential info only
                        elementId = '<span style="color: #60A5FA; font-weight: 600; font-size: 10px;">' + tagName + '</span>';
                        
                        // Show only the most important identifier
                        if (id) {
                            const shortId = id.length > 3 ? id.substring(0, 3) + '…' : id;
                            elementId += '<span style="color: #34D399; font-size: 9px;">#' + shortId + '</span>';
                        } else if (classes.length > 0) {
                            const shortClass = classes[0].length > 3 ? classes[0].substring(0, 3) + '…' : classes[0];
                            elementId += '<span style="color: #FBBF24; font-size: 9px;">.' + shortClass + '</span>';
                        }
                        
                        // Minimal size info
                        elementId += '<span style="color: #9CA3AF; font-size: 8px; margin-left: 3px;">' + 
                                   Math.round(rect.width) + '×' + Math.round(rect.height) + '</span>';
                    } else {
                        // Normal mode with progressive truncation
                        elementId = '<span style="color: #60A5FA; font-weight: 600;">&lt;' + tagName + '&gt;</span>';
                        
                        if (id) {
                            const displayId = isVeryNarrow && id.length > 8 ? id.substring(0, 8) + '…' : id;
                            elementId += '<span style="color: #34D399;">#' + displayId + '</span>';
                        }
                        
                        if (classes.length > 0) {
                            const maxClasses = isNarrow ? 1 : 2;
                            const displayClasses = classes.slice(0, maxClasses);
                            if (isVeryNarrow) {
                                const firstClass = displayClasses[0];
                                const displayClass = firstClass.length > 6 ? firstClass.substring(0, 6) + '…' : firstClass;
                                elementId += '<span style="color: #FBBF24;">.' + displayClass + '</span>';
                            } else {
                                elementId += '<span style="color: #FBBF24;">.' + displayClasses.join('.') + '</span>';
                            }
                            
                            if (classes.length > maxClasses) {
                                elementId += '<span style="color: #9CA3AF;">+' + (classes.length - maxClasses) + '</span>';
                            }
                        }
                        
                        // Add size info
                        const sizeText = isNarrow ? 
                            Math.round(rect.width) + '×' + Math.round(rect.height) :
                            Math.round(rect.width) + '×' + Math.round(rect.height) + 'px';
                        elementId += '<span style="color: #9CA3AF; font-size: 10px; margin-left: 6px;">' + sizeText + '</span>';
                    }
                    
                    infoSection.innerHTML = elementId;
                    
                    // Create responsive buttons
                    buttonSection.innerHTML = '';
                    
                    // Streamlined button configuration focusing on core actions
                    let buttonConfigs;
                    
                    if (needsCompactMode) {
                        // Ultra-compact: icon only for maximum space efficiency
                        buttonConfigs = [
                            { text: '📋', action: 'copy', primary: true, isIcon: true }
                        ];
                    } else if (isVeryNarrow) {
                        // Mobile: icon + one text button
                        buttonConfigs = [
                            { text: '📋', action: 'copy', primary: true, isIcon: true },
                            { text: 'CSS', action: 'css' }
                        ];
                    } else if (isNarrow) {
                        // Tablet: icon + dropdown for secondary actions
                        buttonConfigs = [
                            { text: '📋', action: 'copy', primary: true, isIcon: true },
                            { text: '⋯', action: 'menu', dropdown: [
                                { text: 'CSS Selector', action: 'css' },
                                { text: 'XPath', action: 'xpath' }
                            ]}
                        ];
                    } else {
                        // Desktop: icon + CSS button for optimal space usage
                        buttonConfigs = [
                            { text: '📋', action: 'copy', primary: true, isIcon: true },
                            { text: 'CSS', action: 'css' }
                        ];
                    }
                    
                    buttonConfigs.forEach(config => {
                        if (config.action === 'menu') {
                            // Create dropdown menu button
                            createDropdownButton(config, buttonSection, element, rect, tagName, id, classes, needsCompactMode);
                        } else {
                            // Create regular button
                            createRegularButton(config, buttonSection, element, rect, tagName, id, classes, isVeryNarrow);
                        }
                    });
                }
                
                // Helper function to create regular buttons
                function createRegularButton(config, buttonSection, element, rect, tagName, id, classes, isVeryNarrow) {
                    // Disabled to remove all CSS/XPath buttons
                    return;
                    const button = document.createElement('button');
                    button.textContent = config.text;
                    
                    // Responsive button styling with icon support
                    const isIcon = config.isIcon || false;
                    const buttonPadding = isIcon ? '6px 6px' : (isVeryNarrow ? '4px 6px' : '5px 8px');
                    const buttonFontSize = isIcon ? '14px' : (isVeryNarrow ? '10px' : '11px');
                    const isPrimary = config.primary || false;
                    
                    button.style.cssText = \`
                        background: \${isPrimary ? 'rgba(59, 130, 246, 0.8)' : 'rgba(255, 255, 255, 0.1)'}; 
                        border: 1px solid \${isPrimary ? 'rgba(59, 130, 246, 0.9)' : 'rgba(255, 255, 255, 0.2)'}; 
                        color: #ffffff; 
                        padding: \${buttonPadding}; 
                        border-radius: \${isIcon ? '50%' : '4px'}; 
                        font-size: \${buttonFontSize}; 
                        cursor: pointer; 
                        white-space: nowrap;
                        transition: all 0.2s;
                        font-weight: \${isPrimary ? '600' : '400'};
                        min-width: \${isIcon ? '28px' : 'auto'};
                        height: \${isIcon ? '28px' : 'auto'};
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    \`;
                    
                    // Add tooltip for icon buttons
                    if (isIcon) {
                        button.title = 'Copy element info to Cursor';
                    }
                    
                    button.addEventListener('mouseenter', () => {
                        button.style.background = isPrimary ? 'rgba(59, 130, 246, 0.9)' : 'rgba(255, 255, 255, 0.2)';
                        button.style.transform = 'translateY(-1px)';
                    });
                    
                    button.addEventListener('mouseleave', () => {
                        button.style.background = isPrimary ? 'rgba(59, 130, 246, 0.8)' : 'rgba(255, 255, 255, 0.1)';
                        button.style.transform = 'translateY(0)';
                    });
                    
                    button.addEventListener('click', () => {
                        handleButtonAction(config.action, element, rect, tagName, id, classes);
                    });
                    
                    buttonSection.appendChild(button);
                }
                
                // Helper function to create dropdown menu button
                function createDropdownButton(config, buttonSection, element, rect, tagName, id, classes, isCompact) {
                    // Disabled to remove all CSS/XPath buttons
                    return;
                    const dropdownContainer = document.createElement('div');
                    dropdownContainer.style.position = 'relative';
                    dropdownContainer.style.display = 'inline-block';
                    
                    const button = document.createElement('button');
                    button.textContent = config.text;
                    
                    const buttonPadding = isCompact ? '3px 6px' : '4px 8px';
                    const buttonFontSize = isCompact ? '10px' : '11px';
                    
                    button.style.cssText = \`
                        background: rgba(255, 255, 255, 0.1); 
                        border: 1px solid rgba(255, 255, 255, 0.2); 
                        color: #ffffff; 
                        padding: \${buttonPadding}; 
                        border-radius: 4px; 
                        font-size: \${buttonFontSize}; 
                        cursor: pointer; 
                        white-space: nowrap;
                        transition: all 0.2s;
                    \`;
                    
                    // Create dropdown menu
                    const dropdown = document.createElement('div');
                    dropdown.style.cssText = \`
                        position: absolute;
                        top: 100%;
                        right: 0;
                        background: rgba(0, 0, 0, 0.9);
                        border: 1px solid rgba(255, 255, 255, 0.2);
                        border-radius: 4px;
                        padding: 4px 0;
                        min-width: 120px;
                        z-index: 1000;
                        display: none;
                        backdrop-filter: blur(10px);
                    \`;
                    
                    config.dropdown.forEach(item => {
                        const menuItem = document.createElement('div');
                        menuItem.textContent = item.text;
                        menuItem.style.cssText = \`
                            padding: 6px 12px;
                            color: #ffffff;
                            cursor: pointer;
                            font-size: 11px;
                            transition: background 0.2s;
                        \`;
                        
                        menuItem.addEventListener('mouseenter', () => {
                            menuItem.style.background = 'rgba(255, 255, 255, 0.1)';
                        });
                        
                        menuItem.addEventListener('mouseleave', () => {
                            menuItem.style.background = 'transparent';
                        });
                        
                        menuItem.addEventListener('click', () => {
                            handleButtonAction(item.action, element, rect, tagName, id, classes);
                            dropdown.style.display = 'none';
                        });
                        
                        dropdown.appendChild(menuItem);
                    });
                    
                    // Toggle dropdown on button click
                    button.addEventListener('click', (e) => {
                        e.stopPropagation();
                        dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
                    });
                    
                    // Close dropdown when clicking outside
                    document.addEventListener('click', () => {
                        dropdown.style.display = 'none';
                    });
                    
                    button.addEventListener('mouseenter', () => {
                        button.style.background = 'rgba(255, 255, 255, 0.2)';
                    });
                    
                    button.addEventListener('mouseleave', () => {
                        button.style.background = 'rgba(255, 255, 255, 0.1)';
                    });
                    
                    dropdownContainer.appendChild(button);
                    dropdownContainer.appendChild(dropdown);
                    buttonSection.appendChild(dropdownContainer);
                }
                
                // Centralized button action handler
                function handleButtonAction(action, element, rect, tagName, id, classes) {
                    let textToCopy = '';
                    let notificationText = '';
                    
                    switch (action) {
                        case 'copy':
                            textToCopy = \`Element: <\${tagName}>\${id ? ' #' + id : ''}\${classes.length > 0 ? ' .' + classes.join('.') : ''}
Size: \${Math.round(rect.width)}×\${Math.round(rect.height)}px
Selector: \${tagName}\${id ? '#' + id : ''}\${classes.length > 0 ? '.' + classes.join('.') : ''}\`;
                            notificationText = '📋 Element info copied to Cursor!';
                            break;
                        case 'css':
                            textToCopy = tagName + (id ? '#' + id : '') + (classes.length > 0 ? '.' + classes.join('.') : '');
                            notificationText = '🎯 CSS selector copied!';
                            break;
                        case 'xpath':
                            let xpath = '//' + tagName;
                            if (id) xpath += '[@id="' + id + '"]';
                            else if (classes.length > 0) xpath += '[@class="' + classes.join(' ') + '"]';
                            textToCopy = xpath;
                            notificationText = '🔍 XPath copied!';
                            break;
                    }
                    
                    navigator.clipboard.writeText(textToCopy).then(() => {
                        console.log('[DOM Agent] Copied:', textToCopy);
                        showNotification(notificationText);
                    }).catch(err => {
                        console.error('[DOM Agent] Copy failed:', err);
                        showNotification('❌ Copy failed - check permissions');
                    });
                }
                
                // Smart selection box styling for enhanced visibility of small elements
                function applySmartSelectionStyle(overlayDiv, rect) {
                    const isSmallElement = rect.width < 20 || rect.height < 20;
                    const isTinyElement = rect.width < 10 || rect.height < 10;
                    const isVeryTinyElement = rect.width < 5 || rect.height < 5;
                    
                    // Get or create the selection box (border element)
                    let selectionBox = overlayDiv.querySelector('.dom-agent-selection-box');
                    if (!selectionBox) {
                        selectionBox = document.createElement('div');
                        selectionBox.className = 'dom-agent-selection-box';
                        selectionBox.style.position = 'absolute';
                        selectionBox.style.top = '0';
                        selectionBox.style.left = '0';
                        selectionBox.style.width = '100%';
                        selectionBox.style.height = '100%';
                        selectionBox.style.pointerEvents = 'none';
                        selectionBox.style.zIndex = '1';
                        overlayDiv.appendChild(selectionBox);
                    }
                    
                    if (isVeryTinyElement) {
                        // For very tiny elements (< 5px), create a larger visual indicator
                        selectionBox.style.border = '3px solid #ff6b35';
                        selectionBox.style.background = 'rgba(255, 107, 53, 0.15)';
                        selectionBox.style.boxShadow = '0 0 0 1px rgba(255, 107, 53, 0.4), 0 0 8px rgba(255, 107, 53, 0.6), inset 0 0 0 1px rgba(255, 255, 255, 0.3)';
                        selectionBox.style.transform = 'scale(1.5)';
                        selectionBox.style.transformOrigin = 'center';
                        selectionBox.style.borderRadius = '2px';
                        selectionBox.style.animation = 'dom-agent-pulse 1.5s ease-in-out infinite alternate';
                    } else if (isTinyElement) {
                        // For tiny elements (< 10px), enhance border and add glow
                        selectionBox.style.border = '2px solid #ff6b35';
                        selectionBox.style.background = 'rgba(255, 107, 53, 0.1)';
                        selectionBox.style.boxShadow = '0 0 0 1px rgba(255, 107, 53, 0.3), 0 0 6px rgba(255, 107, 53, 0.5), inset 0 0 0 1px rgba(255, 255, 255, 0.2)';
                        selectionBox.style.transform = 'scale(1.2)';
                        selectionBox.style.transformOrigin = 'center';
                        selectionBox.style.borderRadius = '1px';
                    } else if (isSmallElement) {
                        // For small elements (< 20px), add enhanced visibility
                        selectionBox.style.border = '2px solid #ff6b35';
                        selectionBox.style.background = 'rgba(255, 107, 53, 0.08)';
                        selectionBox.style.boxShadow = '0 0 0 1px rgba(255, 107, 53, 0.25), 0 0 4px rgba(255, 107, 53, 0.4)';
                        selectionBox.style.borderRadius = '1px';
                    } else {
                        // For normal-sized elements, use standard styling
                        selectionBox.style.border = '1px solid #ff6b35';
                        selectionBox.style.background = 'rgba(255, 107, 53, 0.05)';
                        selectionBox.style.boxShadow = '0 0 0 1px rgba(255, 107, 53, 0.2)';
                    }
                    
                    // Add pulse animation keyframes if not already present
                    if (!document.querySelector('#dom-agent-pulse-animation')) {
                        const style = document.createElement('style');
                        style.id = 'dom-agent-pulse-animation';
                        style.textContent = '@keyframes dom-agent-pulse { 0% { transform: scale(1.5); box-shadow: 0 0 0 1px rgba(255, 107, 53, 0.4), 0 0 8px rgba(255, 107, 53, 0.6); } 100% { transform: scale(1.8); box-shadow: 0 0 0 2px rgba(255, 107, 53, 0.6), 0 0 12px rgba(255, 107, 53, 0.8); } }';
                        document.head.appendChild(style);
                    }
                    
                    // Add crosshair indicator for very tiny elements
                    if (isVeryTinyElement) {
                        let crosshair = overlayDiv.querySelector('.dom-agent-crosshair');
                        if (!crosshair) {
                            crosshair = document.createElement('div');
                            crosshair.className = 'dom-agent-crosshair';
                            crosshair.style.position = 'absolute';
                            crosshair.style.top = '50%';
                            crosshair.style.left = '50%';
                            crosshair.style.width = '12px';
                            crosshair.style.height = '12px';
                            crosshair.style.margin = '-6px 0 0 -6px';
                            crosshair.style.pointerEvents = 'none';
                            crosshair.style.zIndex = '2';
                            
                            const horizontalLine = document.createElement('div');
                            horizontalLine.style.position = 'absolute';
                            horizontalLine.style.top = '50%';
                            horizontalLine.style.left = '0';
                            horizontalLine.style.width = '100%';
                            horizontalLine.style.height = '1px';
                            horizontalLine.style.background = '#ff6b35';
                            horizontalLine.style.marginTop = '-0.5px';
                            
                            const verticalLine = document.createElement('div');
                            verticalLine.style.position = 'absolute';
                            verticalLine.style.top = '0';
                            verticalLine.style.left = '50%';
                            verticalLine.style.width = '1px';
                            verticalLine.style.height = '100%';
                            verticalLine.style.background = '#ff6b35';
                            verticalLine.style.marginLeft = '-0.5px';
                            
                            crosshair.appendChild(horizontalLine);
                            crosshair.appendChild(verticalLine);
                            overlayDiv.appendChild(crosshair);
                        }
                    }
                }
                
                // Professional positioning using Floating UI library
                async function positionInspectorBar(inspectorBar, elementRect, viewportWidth, viewportHeight, scrollX, scrollY) {
                    // Check if Floating UI is available
                    if (typeof FloatingUIDOM === 'undefined') {
                        console.warn('[DOM Agent] Floating UI not loaded, falling back to basic positioning');
                        inspectorBar.style.position = 'absolute';
                        inspectorBar.style.top = '-45px';
                        inspectorBar.style.left = '0px';
                        inspectorBar.style.width = '300px';
                        return;
                    }
                    // Reset positioning styles
                    inspectorBar.style.top = '';
                    inspectorBar.style.bottom = '';
                    inspectorBar.style.left = '';
                    inspectorBar.style.right = '';
                    inspectorBar.style.width = '';
                    inspectorBar.style.transform = '';
                    inspectorBar.style.minWidth = '250px';
                    inspectorBar.style.maxWidth = '400px';
                    
                    // Create virtual reference element for positioning
                    const referenceElement = {
                        getBoundingClientRect: () => ({
                            x: elementRect.left,
                            y: elementRect.top,
                            width: elementRect.width,
                            height: elementRect.height,
                            top: elementRect.top,
                            left: elementRect.left,
                            right: elementRect.left + elementRect.width,
                            bottom: elementRect.top + elementRect.height,
                        })
                    };
                    
                    // Floating UI inspired positioning logic
                    const computePosition = (reference, floating, options = {}) => {
                        const { placement = 'top', offset: offsetOptions = 6, flip = true, shift = true } = options;
                        
                        const refRect = reference.getBoundingClientRect();
                        const floatingRect = floating.getBoundingClientRect();
                        
                        let x = 0, y = 0;
                        let finalPlacement = placement;
                        
                        // Calculate base position based on placement
                        switch (placement) {
                            case 'top':
                                x = refRect.left + (refRect.width / 2) - (floatingRect.width / 2);
                                y = refRect.top - floatingRect.height - offsetOptions;
                                break;
                            case 'bottom':
                                x = refRect.left + (refRect.width / 2) - (floatingRect.width / 2);
                                y = refRect.bottom + offsetOptions;
                                break;
                            case 'left':
                                x = refRect.left - floatingRect.width - offsetOptions;
                                y = refRect.top + (refRect.height / 2) - (floatingRect.height / 2);
                                break;
                            case 'right':
                                x = refRect.right + offsetOptions;
                                y = refRect.top + (refRect.height / 2) - (floatingRect.height / 2);
                                break;
                        }
                        
                        // Apply flip middleware if enabled
                        if (flip) {
                            const padding = 8;
                            
                            // Check if current placement fits in viewport
                            if (placement === 'top' && y < padding) {
                                // Not enough space above, flip to bottom
                                if (refRect.bottom + floatingRect.height + offsetOptions + padding <= viewportHeight) {
                                    finalPlacement = 'bottom';
                                    y = refRect.bottom + offsetOptions;
                                }
                            } else if (placement === 'bottom' && y + floatingRect.height > viewportHeight - padding) {
                                // Not enough space below, flip to top
                                if (refRect.top - floatingRect.height - offsetOptions >= padding) {
                                    finalPlacement = 'top';
                                    y = refRect.top - floatingRect.height - offsetOptions;
                                }
                            } else if (placement === 'left' && x < padding) {
                                // Not enough space left, flip to right
                                if (refRect.right + floatingRect.width + offsetOptions + padding <= viewportWidth) {
                                    finalPlacement = 'right';
                                    x = refRect.right + offsetOptions;
                                    y = refRect.top + (refRect.height / 2) - (floatingRect.height / 2);
                                }
                            } else if (placement === 'right' && x + floatingRect.width > viewportWidth - padding) {
                                // Not enough space right, flip to left
                                if (refRect.left - floatingRect.width - offsetOptions >= padding) {
                                    finalPlacement = 'left';
                                    x = refRect.left - floatingRect.width - offsetOptions;
                                    y = refRect.top + (refRect.height / 2) - (floatingRect.height / 2);
                                }
                            }
                        }
                        
                        // Enhanced shift middleware with adaptive behavior
                        if (shift) {
                            const padding = 12; // Increased padding for better visibility
                            
                            // Horizontal shift with aggressive adjustment
                            if (x < padding) {
                                x = padding;
                            } else if (x + floatingRect.width > viewportWidth - padding) {
                                const overflow = (x + floatingRect.width) - (viewportWidth - padding);
                                x = Math.max(padding, x - overflow - 10); // Extra 10px buffer
                            }
                            
                            // Vertical shift with smart repositioning
                            if (y < padding) {
                                // If too high, try placing below the reference element
                                const belowY = refRect.bottom + offsetOptions;
                                if (belowY + floatingRect.height <= viewportHeight - padding) {
                                    y = belowY;
                                    finalPlacement = finalPlacement.replace('top', 'bottom');
                                } else {
                                    y = padding;
                                }
                            } else if (y + floatingRect.height > viewportHeight - padding) {
                                // If too low, try placing above the reference element
                                const aboveY = refRect.top - floatingRect.height - offsetOptions;
                                if (aboveY >= padding) {
                                    y = aboveY;
                                    finalPlacement = finalPlacement.replace('bottom', 'top');
                                } else {
                                    y = Math.max(padding, viewportHeight - floatingRect.height - padding);
                                }
                            }
                        }
                        
                        return { x, y, placement: finalPlacement };
                    };
                    
                    // Determine optimal placement based on element size and available space
                    let preferredPlacement = 'top';
                    
                    // For very small elements, prefer side placement
                    if (elementRect.width < 60 || elementRect.height < 30) {
                        const spaceRight = viewportWidth - (elementRect.left + elementRect.width);
                        const spaceLeft = elementRect.left;
                        
                        if (spaceRight >= 250) {
                            preferredPlacement = 'right';
                        } else if (spaceLeft >= 250) {
                            preferredPlacement = 'left';
                        } else {
                            preferredPlacement = 'top';
                        }
                    }
                    
                    // Smart width calculation with space constraints
                    const calculateOptimalWidth = () => {
                        const viewportWidth = window.innerWidth || document.documentElement.clientWidth;
                        const viewportHeight = window.innerHeight || document.documentElement.clientHeight;
                        
                        // Calculate available horizontal space around the element
                        const leftSpace = elementRect.left;
                        const rightSpace = viewportWidth - (elementRect.left + elementRect.width);
                        const topSpace = elementRect.top;
                        const bottomSpace = viewportHeight - (elementRect.top + elementRect.height);
                        
                        // Determine maximum available width based on element position
                        let maxAvailableWidth;
                        
                        // For elements near edges, be more conservative
                        if (leftSpace < 100 || rightSpace < 100) {
                            maxAvailableWidth = Math.min(viewportWidth * 0.8, 280); // 80% of viewport or 280px
                        } else if (topSpace < 60 || bottomSpace < 60) {
                            // Limited vertical space, may need side positioning
                            maxAvailableWidth = Math.max(leftSpace, rightSpace) - 20;
                        } else {
                            // Plenty of space
                            maxAvailableWidth = Math.min(450, elementRect.width * 2, viewportWidth * 0.9);
                        }
                        
                        // Minimum width based on content needs
                        const minWidth = viewportWidth < 480 ? 180 : 220;
                        
                        return Math.max(minWidth, Math.min(maxAvailableWidth, 450));
                    };
                    
                    const optimalWidth = calculateOptimalWidth();
                    inspectorBar.style.width = optimalWidth + 'px';
                    inspectorBar.style.minWidth = 'auto';
                    inspectorBar.style.maxWidth = optimalWidth + 'px'; // Enforce max width
                    
                    try {
                        // Use Floating UI to compute position
                        const {x, y, placement} = await FloatingUIDOM.computePosition(referenceElement, inspectorBar, {
                            placement: preferredPlacement,
                            middleware: [
                                FloatingUIDOM.offset(6),
                                FloatingUIDOM.flip({
                                    fallbackPlacements: ['top', 'bottom', 'right', 'left']
                                }),
                                FloatingUIDOM.shift({
                                    padding: 8
                                }),
                                FloatingUIDOM.size({
                                    apply({elements, rects, availableWidth, availableHeight}) {
                                        // Ensure the inspector bar doesn't exceed available space
                                        const maxWidth = Math.min(400, availableWidth - 16);
                                        if (maxWidth > 250) {
                                            elements.floating.style.maxWidth = maxWidth + 'px';
                                        }
                                    }
                                })
                            ]
                        });
                        
                        // Apply the computed position
                        inspectorBar.style.position = 'absolute';
                        inspectorBar.style.left = (x - elementRect.left) + 'px';
                        inspectorBar.style.top = (y - elementRect.top) + 'px';
                        
                        // Apply appropriate border radius based on final placement
                        switch (placement) {
                            case 'top':
                                inspectorBar.style.borderRadius = '4px 4px 0 0';
                                break;
                            case 'bottom':
                                inspectorBar.style.borderRadius = '0 0 4px 4px';
                                break;
                            case 'left':
                                inspectorBar.style.borderRadius = '4px 0 0 4px';
                                break;
                            case 'right':
                                inspectorBar.style.borderRadius = '0 4px 4px 0';
                                break;
                            default:
                                inspectorBar.style.borderRadius = '6px';
                        }
                        
                        console.log('[DOM Agent] Inspector positioned with Floating UI:', placement, 'at', Math.round(x), Math.round(y));
                        
                    } catch (error) {
                        console.warn('[DOM Agent] Floating UI positioning failed, using fallback:', error);
                        // Fallback to basic positioning
                        inspectorBar.style.position = 'absolute';
                        inspectorBar.style.top = '-45px';
                        inspectorBar.style.left = '0px';
                    }
                }
                
                // Hide overlay
                function hideOverlay() {
                    if (overlayDiv) {
                        overlayDiv.style.display = 'none';
                    }
                }
                
                // Show notification
                function showNotification(message) {
                    const notification = document.createElement('div');
                    notification.textContent = message;
                    notification.style.cssText = 'position: fixed; top: 20px; right: 20px; background: rgba(34, 197, 94, 0.9); color: white; padding: 12px 16px; border-radius: 6px; font-size: 14px; font-weight: 500; z-index: 10003; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);';
                    document.body.appendChild(notification);
                    setTimeout(() => notification.remove(), 2000);
                }
                
                // Enhanced UX variables with click-lock mechanism
                let hoverTimeout = null;
                let leaveTimeout = null;
                let isElementLocked = false;  // Global lock state
                let lockedElement = null;     // Currently locked element
                let stabilityTimeout = null;
                const HOVER_DELAY = 100;
                const STABILITY_DELAY = 200;
                const LEAVE_DELAY = 150;
                
                // Professional mouseover handler using Driver.js
                function handleMouseOver(e) {
                    if (e.target.tagName === 'SCRIPT' || e.target.tagName === 'STYLE') return;
                    if (e.target.closest('.driver-overlay') || e.target.closest('.driver-popover')) return;
                    
                    // If an element is locked, ignore hover events unless it's the locked element
                    if (isElementLocked && e.target !== lockedElement) {
                        return;
                    }
                    
                    // Debounce hover events to prevent flickering
                    if (hoverTimeout) {
                        clearTimeout(hoverTimeout);
                    }
                    
                    hoverTimeout = setTimeout(() => {
                        currentHoveredElement = e.target;
                        
                        // Use original Driver.js highlight only (no buttons)
                        showOriginalDriverHighlight(e.target);
                        
                        console.log('[DOM Agent] Element highlighted:', e.target.tagName, 'locked:', isElementLocked);
                    }, 50); // Small delay to prevent rapid firing
                }
                
                // Fallback basic highlight function
                function showBasicHighlight(element) {
                    // Remove any existing highlights
                    const existing = document.querySelector('.dom-agent-basic-highlight');
                    if (existing) existing.remove();
                    const existingLocked = document.querySelector('.dom-agent-locked-highlight');
                    if (existingLocked) existingLocked.remove();
                    
                    const rect = element.getBoundingClientRect();
                    const highlight = document.createElement('div');
                    highlight.className = 'dom-agent-basic-highlight';
                    highlight.style.cssText = \`
                        position: absolute;
                        top: \${rect.top + window.pageYOffset}px;
                        left: \${rect.left + window.pageXOffset}px;
                        width: \${rect.width}px;
                        height: \${rect.height}px;
                        border: 2px solid #ff6b35;
                        background: rgba(255, 107, 53, 0.1);
                        pointer-events: none;
                        z-index: 10000;
                        box-sizing: border-box;
                    \`;
                    document.body.appendChild(highlight);
                }
                
                // Locked highlight function with blue styling
                function showLockedHighlight(element) {
                    // Remove any existing highlights
                    const existing = document.querySelector('.dom-agent-basic-highlight');
                    if (existing) existing.remove();
                    const existingLocked = document.querySelector('.dom-agent-locked-highlight');
                    if (existingLocked) existingLocked.remove();
                    
                    const rect = element.getBoundingClientRect();
                    const highlight = document.createElement('div');
                    highlight.className = 'dom-agent-locked-highlight';
                    highlight.style.cssText = \`
                        position: absolute;
                        top: \${rect.top + window.pageYOffset}px;
                        left: \${rect.left + window.pageXOffset}px;
                        width: \${rect.width}px;
                        height: \${rect.height}px;
                        border: 3px solid #3b82f6;
                        background: rgba(59, 130, 246, 0.1);
                        pointer-events: none;
                        z-index: 10001;
                        box-sizing: border-box;
                        box-shadow: 0 0 0 1px rgba(59, 130, 246, 0.3), 0 0 8px rgba(59, 130, 246, 0.4);
                        animation: dom-agent-locked-pulse 2s ease-in-out infinite;
                    \`;
                    document.body.appendChild(highlight);
                }
                
                // Original Driver.js highlight only (no buttons, no custom content)
                function showOriginalDriverHighlight(element) {
                    if (typeof Driver !== 'undefined') {
                        try {
                            // Create basic driver instance with original settings
                            const driverInstance = new Driver({
                                animate: true,
                                opacity: 0.75,
                                padding: 10,
                                allowClose: true,
                                onHighlightStarted: (Element) => {
                                    console.log('[DOM Agent] Original Driver.js highlighting:', Element);
                                }
                            });
                            
                            // Simple highlight with minimal popover (original style)
                            driverInstance.highlight({
                                element: element,
                                popover: {
                                    title: getElementTitle(element),
                                    description: getElementDescription(element),
                                    position: 'auto'
                                }
                            });
                            
                        } catch (error) {
                            console.error('[DOM Agent] Original Driver.js error:', error);
                            // Fall back to just basic highlight without any popover
                            showBasicHighlight(element);
                        }
                    } else {
                        console.warn('[DOM Agent] Driver.js not available');
                        showBasicHighlight(element);
                    }
                }
                
                // Custom info display function (replaces Tippy.js)
                function showCustomInfo(element) {
                    // Completely disabled to remove all buttons
                    return;
                    // Remove any existing custom info
                    const existing = document.querySelector('.dom-agent-custom-info');
                    if (existing) existing.remove();
                    
                    const rect = element.getBoundingClientRect();
                    const info = document.createElement('div');
                    info.className = 'dom-agent-custom-info';
                    const customId = 'dom-agent-custom-' + Date.now();
                    element.setAttribute('data-dom-agent-custom-id', customId);
                    
                    // First create the element with content to measure its height
                    info.innerHTML = \`
                        <div style="font-weight: bold; margin-bottom: 4px;">\${getElementTitle(element)}</div>
                        <div style="font-size: 11px; opacity: 0.8; margin-bottom: 8px;">\${getElementDescription(element)}</div>
                    \`;
                    
                    // Temporarily add to body to measure dimensions
                    info.style.cssText = \`
                        position: absolute;
                        top: -9999px;
                        left: -9999px;
                        background: white;
                        color: #333;
                        padding: 8px;
                        border-radius: 6px;
                        font-size: 12px;
                        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                        border: 1px solid #e5e7eb;
                        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
                        min-width: 200px;
                        max-width: 300px;
                        word-wrap: break-word;
                        visibility: hidden;
                    \`;
                    
                    document.body.appendChild(info);
                    
                    // Measure the actual height
                    const infoHeight = info.offsetHeight;
                    
                    // Now position it correctly - bottom of info box touches top of selection box
                    info.style.cssText = \`
                        position: absolute;
                        top: \${rect.top + window.pageYOffset - infoHeight}px;
                        left: \${rect.left + window.pageXOffset}px;
                        background: white;
                        color: #333;
                        padding: 8px;
                        border-radius: 6px;
                        font-size: 12px;
                        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                        z-index: 10002;
                        pointer-events: auto;
                        border: 1px solid #e5e7eb;
                        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
                        min-width: 200px;
                        max-width: 300px;
                        word-wrap: break-word;
                        visibility: visible;
                    \`;
                }
                
                // Fallback info display when Tippy.js is not available
                function showFallbackInfo(element) {
                    // Completely disabled to remove all buttons
                    return;
                    // Remove any existing fallback info
                    const existing = document.querySelector('.dom-agent-fallback-info');
                    if (existing) existing.remove();
                    
                    const rect = element.getBoundingClientRect();
                    const info = document.createElement('div');
                    info.className = 'dom-agent-fallback-info';
                    const fallbackId = 'dom-agent-fallback-' + Date.now();
                    element.setAttribute('data-dom-agent-fallback-id', fallbackId);
                    
                    info.style.cssText = \`
                        position: absolute;
                        top: \${rect.top + window.pageYOffset - 80}px;
                        left: \${rect.left + window.pageXOffset}px;
                        background: rgba(0, 0, 0, 0.9);
                        color: white;
                        padding: 12px;
                        border-radius: 6px;
                        font-size: 12px;
                        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                        z-index: 10002;
                        pointer-events: auto;
                        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                        min-width: 200px;
                        max-width: 300px;
                        word-wrap: break-word;
                    \`;
                    
                    info.innerHTML = \`
                        <div style="font-weight: bold; margin-bottom: 4px;">\${getElementTitle(element)}</div>
                        <div style="font-size: 11px; opacity: 0.8; margin-bottom: 8px;">\${getElementDescription(element)}</div>
                    \`;
                    
                    document.body.appendChild(info);
                }
                
                // Enhanced mouseleave handler
                function handleMouseLeave(e) {
                    // If element is locked, don't hide on mouse leave
                    if (isElementLocked) return;
                    
                    if (hoverTimeout) {
                        clearTimeout(hoverTimeout);
                    }
                    
                    if (e.target === document.body || e.relatedTarget === null) {
                        // Mouse left the document entirely
                        leaveTimeout = setTimeout(() => {
                            if (!isElementLocked) {
                                // Remove basic highlight
                                const existing = document.querySelector('.dom-agent-basic-highlight');
                                if (existing) existing.remove();
                                
                                // Remove fallback info
                                const fallbackInfo = document.querySelector('.dom-agent-fallback-info');
                                if (fallbackInfo) fallbackInfo.remove();
                                
                                // Clean up tippy instances
                                if (currentHoveredElement && currentHoveredElement._tippy) {
                                    currentHoveredElement._tippy.destroy();
                                }
                            }
                        }, LEAVE_DELAY);
                    }
                }
                
                // Click handler for professional element locking
                function handleClick(e) {
                    console.log('[DOM Agent] Click detected on:', e.target.tagName, e.target.className, 'locked:', isElementLocked);
                    
                    // Check if clicking on Driver.js UI elements
                    const isDriverUI = e.target.closest('.driver-overlay') || 
                                      e.target.closest('.driver-popover') ||
                                      e.target.closest('.driver-stage');
                    
                    if (isDriverUI) {
                        console.log('[DOM Agent] Clicked on Driver UI, ignoring');
                        return;
                    }
                    
                    // If an element is already locked, check if clicking the same element to unlock
                    if (isElementLocked) {
                        if (e.target === lockedElement) {
                            console.log('[DOM Agent] Clicking locked element again, unlocking');
                            unlockElement();
                            return;
                        } else {
                            console.log('[DOM Agent] Element is locked, ignoring click on different element');
                            return;
                        }
                    }
                    
                    // Lock the clicked element
                    console.log('[DOM Agent] Locking element:', e.target.tagName);
                    lockElement(e.target);
                }
                
                // Lock element function using Driver.js
                function lockElement(element) {
                    console.log('[DOM Agent] Locking element:', element.tagName, element.className || element.id || '');
                    
                    isElementLocked = true;
                    lockedElement = element;
                    currentHoveredElement = element;
                    
                    // Show locked highlight with blue styling
                    showLockedHighlight(element);
                    
                    // Show persistent locked info with original Driver.js (no buttons)
                    if (typeof Driver !== 'undefined') {
                        try {
                            const lockedDriverInstance = new Driver({
                                animate: true,
                                opacity: 0.75,
                                padding: 10,
                                allowClose: true
                            });
                            
                            lockedDriverInstance.highlight({
                                element: element,
                                popover: {
                                    title: '🔒 ' + getElementTitle(element),
                                    description: getElementDescription(element) + '\n\n再次点击解锁或按 ESC',
                                    position: 'auto'
                                }
                            });
                            
                        } catch (error) {
                            console.error('[DOM Agent] Driver.js lock error:', error);
                        }
                    }
                    
                    console.log('[DOM Agent] Element successfully locked, isElementLocked:', isElementLocked);
                    showNotification('🔒 Element locked • Click again or press ESC to unlock');
                }
                
                // Unlock element function using Tippy.js
                function unlockElement() {
                    const previousLockedElement = lockedElement;
                    isElementLocked = false;
                    lockedElement = null;
                    
                    // Remove highlights
                    const existing = document.querySelector('.dom-agent-basic-highlight');
                    if (existing) existing.remove();
                    const existingLocked = document.querySelector('.dom-agent-locked-highlight');
                    if (existingLocked) existingLocked.remove();
                    
                    // Remove fallback info
                    const fallbackInfo = document.querySelector('.dom-agent-fallback-info');
                    if (fallbackInfo) fallbackInfo.remove();
                    
                    // Clean up tippy instances
                    if (previousLockedElement && previousLockedElement._tippy) {
                        previousLockedElement._tippy.destroy();
                    }
                    
                    console.log('[DOM Agent] Element unlocked');
                    showNotification('🔓 Element unlocked');
                }
                
                // Keyboard handler for unlocking
                function handleKeyDown(e) {
                    if (e.key === 'Escape' && isElementLocked) {
                        unlockElement();
                    }
                }
                
                // Initialize when DOM is ready
                document.addEventListener('DOMContentLoaded', function() {
                    console.log('[DOM Agent] DOM ready - initializing Driver.js selection system');
                    console.log('[DOM Agent] Driver.js available:', typeof Driver !== 'undefined');
                    
                    // Clean up any existing button elements from previous runs
                    const existingButtons = document.querySelectorAll('.dom-agent-copy-btn');
                    existingButtons.forEach(btn => btn.remove());
                    
                    const existingInfoBoxes = document.querySelectorAll('.dom-agent-fallback-info, .dom-agent-custom-info');
                    existingInfoBoxes.forEach(info => info.remove());
                    
                    // Enhanced event listeners for Driver.js based selection
                    console.log('[DOM Agent] Adding event listeners...');
                    document.addEventListener('mouseover', handleMouseOver);
                    document.addEventListener('mouseleave', handleMouseLeave);
                    document.addEventListener('click', handleClick);
                    document.addEventListener('keydown', handleKeyDown);
                    
                    // Copy button event delegation removed - no buttons to handle
                    
                    console.log('[DOM Agent] Event listeners added successfully');
                    
                    // Add visual styles for highlights and animations
                    const style = document.createElement('style');
                    style.textContent = \`
                        @keyframes dom-agent-locked-pulse {
                            0%, 100% { 
                                border-color: #3b82f6;
                                box-shadow: 0 0 0 1px rgba(59, 130, 246, 0.3), 0 0 8px rgba(59, 130, 246, 0.4);
                            }
                            50% { 
                                border-color: #1d4ed8;
                                box-shadow: 0 0 0 1px rgba(59, 130, 246, 0.5), 0 0 12px rgba(59, 130, 246, 0.6);
                            }
                        }
                        
                        /* Custom Tippy.js styles */
                        .tippy-box[data-theme~='light-border'] {
                            background-color: white;
                            border: 1px solid #e5e7eb;
                            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
                        }
                        
                        .tippy-box[data-theme~='light-border'] .tippy-content {
                            padding: 0;
                            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                        }
                        
                        /* Force remove any gaps */
                        .tippy-box[data-theme~='light-border'] {
                            margin: 0 !important;
                        }
                        
                        .tippy-box[data-theme~='light-border'] .tippy-arrow {
                            margin: 0 !important;
                        }
                        
                        .dom-agent-tooltip {
                            position: fixed;
                            bottom: 20px;
                            right: 20px;
                            background: rgba(0, 0, 0, 0.8);
                            color: white;
                            padding: 8px 12px;
                            border-radius: 6px;
                            font-size: 12px;
                            z-index: 2147483647;
                            pointer-events: none;
                            opacity: 0;
                            transition: opacity 0.3s;
                        }
                        
                        .dom-agent-tooltip.visible {
                            opacity: 1;
                        }
                    \`;
                    document.head.appendChild(style);
                    
                    // Add help tooltip
                    const tooltip = document.createElement('div');
                    tooltip.className = 'dom-agent-tooltip';
                    tooltip.textContent = 'Click any element to lock • Click again or ESC to unlock';
                    document.body.appendChild(tooltip);
                    
                    // Show tooltip briefly on load
                    setTimeout(() => {
                        tooltip.classList.add('visible');
                        setTimeout(() => {
                            tooltip.classList.remove('visible');
                        }, 3000);
                    }, 1000);
                    
                    console.log('[DOM Agent] Enhanced overlay system initialized successfully!');
                });
                } // End of disabled script block
            </script>
            ${interactivityScript}
            <!-- DOM Agent Interactivity Script End -->
        </body>
        </html>`;
    }

    private updateWebviewContent(content: string): void {
        if (this.panel && this.panel.webview) {
            this.panel.webview.html = content;
        }
    }

    private getLoadingContent(): string {
        return `
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>DOM Agent - Loading</title>
            <style>
                body {
                    font-family: var(--vscode-font-family);
                    color: var(--vscode-foreground);
                    background-color: var(--vscode-editor-background);
                    margin: 0;
                    padding: 20px;
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    min-height: 100vh;
                }
                .loading {
                    text-align: center;
                }
                .spinner {
                    width: 40px;
                    height: 40px;
                    border: 4px solid var(--vscode-progressBar-background);
                    border-top: 4px solid var(--vscode-progressBar-foreground);
                    border-radius: 50%;
                    animation: spin 1s linear infinite;
                    margin: 0 auto 20px;
                }
                @keyframes spin {
                    0% { transform: rotate(0deg); }
                    100% { transform: rotate(360deg); }
                }
                h2 {
                    margin: 0 0 12px 0;
                    font-size: 18px;
                }
                p {
                    margin: 0;
                    opacity: 0.7;
                    font-size: 14px;
                }
            </style>
        </head>
        <body>
            <div class="loading">
                <div class="spinner"></div>
                <h2>🔍 Capturing DOM</h2>
                <p>Please wait while we capture the webpage...</p>
            </div>
        </body>
        </html>`;
    }

    private getErrorContent(error: any): string {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
        
        return `
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>DOM Agent - Error</title>
            <style>
                body {
                    font-family: var(--vscode-font-family);
                    color: var(--vscode-foreground);
                    background-color: var(--vscode-editor-background);
                    margin: 0;
                    padding: 20px;
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    min-height: 100vh;
                }
                .error {
                    text-align: center;
                    max-width: 600px;
                }
                .error-icon {
                    font-size: 48px;
                    margin-bottom: 20px;
                }
                h2 {
                    color: var(--vscode-errorForeground);
                    margin: 0 0 16px 0;
                }
                .error-message {
                    background: var(--vscode-inputValidation-errorBackground);
                    border: 1px solid var(--vscode-inputValidation-errorBorder);
                    color: var(--vscode-inputValidation-errorForeground);
                    padding: 12px;
                    border-radius: 4px;
                    font-family: var(--vscode-editor-font-family);
                    margin-bottom: 20px;
                }
                .suggestions {
                    text-align: left;
                    margin-top: 20px;
                }
                .suggestions h3 {
                    margin: 0 0 12px 0;
                }
                .suggestions ul {
                    margin: 0;
                    padding-left: 20px;
                }
                .suggestions li {
                    margin-bottom: 8px;
                    opacity: 0.8;
                }
            </style>
        </head>
        <body>
            <div class="error">
                <div class="error-icon">⚠️</div>
                <h2>Capture Failed</h2>
                <div class="error-message">
                    ${errorMessage}
                </div>
                <div class="suggestions">
                    <h3>Troubleshooting Tips:</h3>
                    <ul>
                        <li>Check if the URL is accessible and valid</li>
                        <li>Ensure you have an internet connection</li>
                        <li>Try a different browser engine in settings</li>
                        <li>Some sites may block automated access</li>
                        <li>Check the extension output for more details</li>
                    </ul>
                </div>
            </div>
        </body>
        </html>`;
    }

    private createWebviewPanel(): void {
        if (this.panel) {
            this.panel.reveal();
            return;
        }

        this.panel = vscode.window.createWebviewPanel(
            'domAgent',
            'DOM Agent',
            vscode.ViewColumn.Two,
            {
                enableScripts: true,
                retainContextWhenHidden: true,
                localResourceRoots: [this.context.extensionUri]
            }
        );

        this.panel.webview.html = this.getWebviewContent();

        this.panel.onDidDispose(() => {
            this.panel = undefined;
        });

        this.panel.webview.onDidReceiveMessage(
            message => this.handleWebviewMessage(message),
            undefined,
            this.context.subscriptions
        );
    }

    private getWebviewContent(): string {
        return `
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>DOM Agent</title>
            <style>
                body {
                    font-family: var(--vscode-font-family);
                    color: var(--vscode-foreground);
                    background-color: var(--vscode-editor-background);
                    margin: 0;
                    padding: 20px;
                }
                .placeholder {
                    text-align: center;
                    margin-top: 50px;
                }
                .logo {
                    font-size: 24px;
                    margin-bottom: 20px;
                }
            </style>
        </head>
        <body>
            <div class="placeholder">
                <div class="logo">🔍 DOM Agent</div>
                <p>Ready to capture and inspect web pages!</p>
                <p>Use the commands to get started:</p>
                <ul style="text-align: left; display: inline-block;">
                    <li>Open URL in DOM Agent</li>
                    <li>Detect Local Dev Server</li>
                </ul>
            </div>
        </body>
        </html>`;
    }

    private async handleWebviewMessage(message: any): Promise<void> {
        this.logger.info('Received webview message', message);
        
        switch (message.type) {
            case 'element-selected':
                this.selectedElement = message.payload.element;
                vscode.commands.executeCommand('setContext', 'dom-agent.hasSelection', true);
                break;
            case 'element-hovered':
                // Handle hover events (no need to store as selected element for now)
                this.logger.debug('Element hovered in webview', message.payload);
                break;
            case 'element-unhovered':
                // Handle unhover events
                this.logger.debug('Element unhovered in webview');
                break;
            case 'open-cursor-chat':
                await this.handleOpenCursorChat(message.payload);
                break;
        }
    }

    private async handleOpenCursorChat(payload: any): Promise<void> {
        const element = payload.element || this.selectedElement;
        
        if (!element) {
            vscode.window.showErrorMessage('No element selected for Cursor Chat');
            return;
        }

        try {
            const framework = payload.framework || 'react';
            const type = payload.type || 'component';
            
            // Create a detailed prompt for Cursor Chat
            const elementContext = `
Element Information:
- Tag: <${element.tag}>
- ID: ${element.id || 'none'}
- Classes: ${element.classes.length > 0 ? element.classes.join(', ') : 'none'}
- CSS Selector: ${element.cssSelector}
- XPath: ${element.xpath}
- Size: ${element.boundingBox.width}px × ${element.boundingBox.height}px
- Text Content: ${element.textContent ? `"${element.textContent.substring(0, 100)}${element.textContent.length > 100 ? '...' : ''}"` : 'none'}

Request: Generate a ${framework} ${type} based on this element.
`;

            // Copy context to clipboard for easy pasting in Cursor Chat
            await vscode.env.clipboard.writeText(elementContext);

            // Try to open Cursor Chat command
            try {
                await vscode.commands.executeCommand('cursor.chat.open');
                
                // Send success message back to webview
                if (this.panel) {
                    this.panel.webview.postMessage({
                        type: 'cursor-chat-opened',
                        payload: { success: true }
                    });
                }

                vscode.window.showInformationMessage(
                    'Cursor Chat opened! Element context has been copied to clipboard - paste it in the chat.',
                    'Got it'
                );

            } catch (chatError) {
                // Fallback: try to open command palette with cursor chat
                await vscode.commands.executeCommand('workbench.action.showCommands');
                
                vscode.window.showInformationMessage(
                    'Element context copied to clipboard. Type "Cursor: Chat" in the command palette to open chat.',
                    'OK'
                );

                if (this.panel) {
                    this.panel.webview.postMessage({
                        type: 'cursor-chat-opened',
                        payload: { success: true, fallback: true }
                    });
                }
            }

        } catch (error) {
            this.logger.error('Failed to open Cursor Chat', error);
            
            if (this.panel) {
                this.panel.webview.postMessage({
                    type: 'cursor-chat-error',
                    payload: { error: error instanceof Error ? error.message : 'Unknown error' }
                });
            }

            vscode.window.showErrorMessage('Failed to open Cursor Chat. Element context has been copied to clipboard.');
        }
    }

    public focus(): void {
        if (this.panel) {
            this.panel.reveal(vscode.ViewColumn.One);
        }
    }

    // triggerAIGeneration method removed - now using Cursor Chat integration
}